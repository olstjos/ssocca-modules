<?php

/**
 * @file
 * Module file for Contentimport.
 */

use Drupal\node\Entity\Node;
use Drupal\file\Entity\File;
use Drupal\taxonomy\Entity\Vocabulary;
use Drupal\taxonomy\Entity\Term;
use Drupal\user\Entity\User;

/**
 * Implements hook_preprocess_page().
 */
function contentimport_preprocess_page(&$variables) {
  $variables['page']['#cache']['contexts'][] = 'route';
  $urlRoute = \Drupal::routeMatch()->getRouteName();
  if (($urlRoute == 'contentimport.admin_settings')) {
    $variables['#attached']['library'][] = 'contentimport/common-styling';
  }
}

/**
 * To get all Content Type Fields.
 */
function get_fields($contentType) {
  $fields = [];
  foreach (\Drupal::service('entity_field.manager')
    ->getFieldDefinitions('node', $contentType) as $field_definition) {
    if (!empty($field_definition->getTargetBundle())) {
      $fields['name'][] = $field_definition->getName();
      $fields['type'][] = $field_definition->getType();
      $fields['setting'][] = $field_definition->getSettings();
    }
  }
  return $fields;
}

/**
 * To get Reference field ids.
 */
function get_term_reference($voc, $terms) {
  //print "|$terms|<br >";
  $vocName = strtolower($voc);
  $vid = preg_replace('@[^a-z0-9_]+@', '_', $vocName);
  $vocabularies = Vocabulary::loadMultiple();
  
  if (!isset($vocabularies[$vid])) {
   // create_voc($vid, $voc);
   \Drupal::messenger()
   ->addError(t('Vocabulary not exists please add the vocabulary and import again'));

  }
  $termArray = array_map('trim', explode(',', $terms));
  $termIds = [];
  foreach ($termArray as $term) {
    $term_id = get_term_id($term, $vid);
    if (empty($term_id)) {
      //$term_id = create_term($voc, $term, $vid);
      \Drupal::messenger()
      ->addError(t('Term does not exist'));
    }
    $termIds[]['target_id'] = $term_id;
  }
  return $termIds;
}

/**
 * To Create Terms if it is not available.
 */
function create_voc($vid, $voc) {
  $vocabulary = Vocabulary::create(
        [
          'vid' => $vid,
          'machine_name' => $vid,
          'name' => $voc,
        ]
    );
  $vocabulary->save();
}

/**
 * To Create Terms if it is not available.
 */
function create_term($voc, $term, $vid) {
  Term::create(
        [
          'parent' => [$voc],
          'name' => $term,
          'vid' => $vid,
        ]
    )->save();
  $termId = get_term_id($term, $vid);
  return $termId;
}

/**
 * To get Termid available.
 */
function get_term_id($term, $vid) {
  $query = \Drupal::database()->select('taxonomy_term_field_data', 't');
  $query->fields('t', ['tid']);
  $query->condition('t.vid', $vid);
  $query->condition('t.name', $term);
  $termRes = $query->execute()->fetchAll();
  foreach ($termRes as $val) {
    $term_id = $val->tid;
  }
  return $term_id;
}

/**
 * To get node available.
 */
function get_node_id($title) {
  $nodeReference = [];
  $db = \Drupal::database();
  foreach ($title as $key => $value) {
    $query = $db->select('node_field_data', 'n');
    $query->fields('n', ['nid']);
    $nodeId = $query
      ->condition('n.title', trim($value))
      ->execute()
      ->fetchField();
    $nodeReference[$key]['target_id'] = $nodeId;
  }
  return $nodeReference;
}

/**
 * To get user id.
 */
function get_user_id($name) {
  $user_id = \Drupal::database()
    ->select('users_field_data', 'u')
    ->fields('u', ['uid'])
    ->condition('u.name', trim($name))
    ->execute()
    ->fetchField();
  return $user_id;
}

/**
 * To get user information based on emailIds.
 */
function get_user_info($userArray) {
  $uids = [];
  foreach ($userArray as $usermail) {
    if (filter_var($usermail, FILTER_VALIDATE_EMAIL)) {
      $users = \Drupal::entityTypeManager()->getStorage('user')
        ->loadByProperties(
                [
                  'mail' => $usermail,
                ]
            );
    }
    else {
      $users = \Drupal::entityTypeManager()->getStorage('user')
        ->loadByProperties(
                [
                  'name' => $usermail,
                ]
            );
    }
    $user = reset($users);
    if ($user) {
      $uids[] = $user->id();
    }
    else {
      $user = User::create();
      $user->uid = '';
      $user->setUsername($usermail);
      $user->setEmail($usermail);
      $user->set("init", $usermail);
      $user->enforceIsNew();
      $user->activate();
      $user->save();
      $users = \Drupal::entityTypeManager()->getStorage('user')
        ->loadByProperties(['mail' => $usermail]);
      $uids[] = $user->id();
    }
  }
  return $uids;
}

/**
 * Get matching nids for given node data
 * 
 * @param array $data Node data
 * @return array Matching node IDs
 */
function get_matching_nodes($data) {
  //print "<pre>";
  //print_r($data);
  //print "</pre>";
  
  $query = \Drupal::entityQuery('node')
    ->condition('title', $data['title']['value'])
    ->condition('langcode', $data['langcode'])
    ->condition('type', $data['type']);
  
  // Add type-specific conditions
  if ($data['type'] == 'complaint_link') {
    $query->condition('field_link_complaint', $data['field_link_complaint']);
  } else if ($data['type'] == 'info_link') {
    $query->condition('field_link_info', $data['field_link_info']);
  }
  $nids = $query->execute();

  return array_values($nids);
}

/**
 * Process field type
 * 
 * @param array $data Import record
 * @param array $keyIndex
 * @param array $fieldSettings Field settings for content type
 * @param string $fieldType Field type
 * @param string $fieldName Machine name of field
 * @param string $contentType Node content type
 * @return array Updated node data
 */
function process_field($data, $keyIndex, $fieldSettings, $fieldType, $fieldName, $contentType) {
  switch ($fieldType) {
    case 'image':
      $logVariationFields .= "Importing Image (" . trim($data[$keyIndex[$fieldName]]) . ") :: ";
      if (!empty($data[$keyIndex[$fieldName]])) {
        $imgIndex = trim($data[$keyIndex[$fieldName]]);
        $files = glob('sites/default/files/' . $contentType . '/images/' . $imgIndex);
        $fileExists = file_exists('sites/default/files/' . $imgIndex);
        if (!$fileExists) {
          $images = [];
          foreach ($files as $file_name) {
            $image = File::create(['uri' => 'public://' . $contentType . '/images/' . basename($file_name)]);
            $image->save();
            $images[basename($file_name)] = $image;
            $imageId = $images[basename($file_name)]->id();
          }
          $nodeArrayEn[$fieldName] = [
            [
              'target_id' => $imageId,
              'alt' => $images['title'],
              'title' => $images['title'],
            ],
          ];
          $logVariationFields .= "Image uploaded successfully \n ";
        }
      }
      //$logVariationFields .= " Success \n";
      break;

    case 'entity_reference':
      $logVariationFields .= "Importing Reference Type (" . $fieldSettings['target_type'] . ") :: ";
      if ($fieldSettings['target_type'] == 'taxonomy_term') {
        $target_bundles = $fieldSettings['handler_settings']['target_bundles'];
        // If vocabulary field settings target is single, assume it.
        if (count($target_bundles) == 1 && !empty($data[$keyIndex[$fieldName]])) {
          $terms = get_term_reference($target_bundles[key($target_bundles)], $data[$keyIndex[$fieldName]]);
        }
        // If not, assume vocabulary is added with ":" delimiter.
        else {
          $reference = explode(":", $data[$keyIndex[$fieldName]]);
          if (is_array($reference) && $reference[0] != '') {
            $terms = get_term_reference($reference[0], $reference[1]);
          }
        }
        if (!empty($terms)) {
          $nodeArrayEn[$fieldName] = $terms;
        } else {
          // Log an error
        }
      }
      elseif ($fieldSettings['target_type'] == 'user') {
        $userArray = explode(', ', $data[$keyIndex[$fieldName]]);
        $users = get_user_info($userArray);
        $nodeArrayEn[$fieldName] = $users;
      }
      elseif ($fieldSettings['target_type'] == 'node') {
        $nodeArrayEns = explode(':', $data[$keyIndex[$fieldName]]);
        $nodeReference1 = get_node_id($nodeArrayEns);
        $nodeArrayEn[$fieldName] = $nodeReference1;
      }
      //$logVariationFields .= " Success \n";
      break;

    case 'text_long':
    case 'text':
      $logVariationFields .= "Importing Content (" . $fieldName . ") :: ";
      $nodeArrayEn[$fieldName] = [
        'value' => $data[$keyIndex[$fieldName]],
        'format' => 'full_html',
      ];
      $logVariationFields .= " Success \n";
      break;

    case 'entity_reference_revisions':
    case 'text_with_summary':
      $logVariationFields .= "Importing Content (" . $fieldName . ") :: ";
      $nodeArrayEn[$fieldName] = [
        'summary' => substr(strip_tags($data[$keyIndex[$fieldName]]), 0, 100),
        'value' => $data[$keyIndex[$fieldName]],
        'format' => 'full_html',
      ];
      //$logVariationFields .= " Success \n";

      break;

    case 'datetime':
      $logVariationFields .= "Importing Datetime (" . $fieldName . ") :: ";
      $dateArray = explode(':', $data[$keyIndex[$fieldName]]);
      if (count($dateArray) > 1) {
        $dateTimeStamp = strtotime($data[$keyIndex[$fieldName]]);
        $newDateString = date('Y-m-d\TH:i:s', $dateTimeStamp);
      }
      else {
        $dateTimeStamp = strtotime($data[$keyIndex[$fieldName]]);
        $newDateString = date('Y-m-d', $dateTimeStamp);
      }
      $nodeArrayEn[$fieldName] = ["value" => $newDateString];
      //$logVariationFields .= " Success \n";
      break;

    case 'timestamp':
      $logVariationFields .= "Importing Content (" . $fieldName . ") :: ";
      $nodeArrayEn[$fieldName] = ["value" => $data[$keyIndex[$fieldName]]];
      //$logVariationFields .= " Success \n";
      break;

    case 'boolean':
      //$logVariationFields .= "Importing Boolean (" . $fieldName . ") :: ";
      $affirmative = ['On','on','Yes','yes',1,'Oui','oui'];
      $nodeArrayEn[$fieldName] = in_array($data[$keyIndex[$fieldName]], $affirmative);
      //$logVariationFields .= " Success \n";
      break;

    case 'langcode':
      $logVariationFields .= "Importing Langcode (" . $fieldName . ") :: ";
      $nodeArrayEn[$fieldName] = ($data[$keyIndex[$fieldName]] != '') ? $data[$keyIndex[$fieldName]] : 'en';
      //$logVariationFields .= " Success \n";
      break;

    case 'geolocation':
      $logVariationFields .= "Importing Geolocation Field (" . $fieldName . ") :: ";
      $geoArray = explode(";", $data[$keyIndex[$fieldName]]);
      if (count($geoArray) > 0) {
        $geoMultiArray = [];
        for ($g = 0; $g < count($geoArray); $g++) {
          $latlng = explode(",", $geoArray[$g]);
          for ($l = 0; $l < count($latlng); $l++) {
            $latlng[$l] = floatval(preg_replace("/\[^0-9,.]/", "", $latlng[$l]));
          }
          array_push(
                $geoMultiArray, [
                  'lat' => $latlng[0],
                  'lng' => $latlng[1],
                ]
            );
        }
        $nodeArrayEn[$fieldName] = $geoMultiArray;
      }
      else {
        $latlng = explode(",", $data[$keyIndex[$fieldName]]);
        for ($l = 0; $l < count($latlng); $l++) {
          $latlng[$l] = floatval(preg_replace("/\[^0-9,.]/", "", $latlng[$l]));
        }
        $nodeArrayEn[$fieldName] = ['lat' => $latlng[0], 'lng' => $latlng[1]];
      }
      //$logVariationFields .= " Success \n";
      break;

    case 'entity_reference_revisions':
      /* In Progress */
      break;

    case 'list_string':
      $logVariationFields .= "Importing Content (" . $fieldName . ") :: ";
      $listArray = explode(",", $data[$keyIndex[$fieldName]]);
      array_walk($listArray, 'trim');
      $nodeArrayEn[$fieldName] = $listArray;
      //$logVariationFields .= " Success \n";
      break;

    case 'geofield':
      $logVariationFields .= "Importing Geofield Field (" . $fieldName . ") :: ";
      if (!empty(trim($data[$keyIndex[$fieldName]]))) {
        $geoFieldArray = explode(";", trim($data[$keyIndex[$fieldName]]));
        if (count($geoFieldArray) > 0) {
          $geoFieldMultiArray = [];
          for ($g = 0; $g < count($geoFieldArray); $g++) {
            $latlng = explode(",", $geoFieldArray[$g]);
            for ($l = 0; $l < count($latlng); $l++) {
              $latlng[$l] = floatval($latlng[$l]);
            }
            array_push($geoFieldMultiArray,
            \Drupal::service('geofield.wkt_generator')->WktBuildPoint([trim($latlng[1]), trim($latlng[0])]));
          }
          $nodeArrayEn[$fieldName] = $geoFieldMultiArray;
        }
        else {
          $latlng = explode(",", trim($data[$keyIndex[$fieldName]]));
          for ($l = 0; $l < count($latlng); $l++) {
            $latlng[$l] = floatval($latlng[$l]);
          }
          $lonlat = \Drupal::service('geofield.wkt_generator')->WktBuildPoint([trim($latlng[1]), trim($latlng[0])]);
          $nodeArrayEn[$fieldName] = $lonlat;
        }
        //$logVariationFields .= " Success \n";
      }
      break;

    case 'authored_by':
      $logVariationFields .= "Importing Content (" . $fieldName . ") :: ";
      $user_id = get_user_id($data[$keyIndex[$fieldName]]);
      $nodeArrayEn['uid'] = ($user_id > 0) ? $user_id : \Drupal::currentUser()->id();
      //$logVariationFields .= " Success \n";
      break;

    default:
      $nodeArrayEn[$fieldName] = $data[$keyIndex[$fieldName]];
      break;
  }

}

/**
 * Get errors for record
 * 
 * @param array $data Node data
 * @return array Errors
 */
function get_record_errors($data) {
  $errors = [];
  if ($data['type'] == 'complaint_link') {
    if ( !isset($data['field_sector']) || empty($data['field_sector']) ) {
      $errors[] = t('Missing Sector');
    }
    if ($data['field_link_complaint'] == '') {
      $errors[] = t('Missing Complaint link');
    }
  } else if ($data['type'] == 'info_link') {
    if ( !isset($data['field_sector']) || empty($data['field_sector']) ) {
      $errors[] = t('Missing Sector');
    }
    if ($data['field_link_info'] == '') {
      $errors[] = t('Missing Info link');
    }
  }

  return $errors;
}

function format_header($header, $contentType) {
  foreach ($header as $key => $columnName) {
    if ( $contentType == 'complaint_link' && in_array($columnName, ['field_link','field_link_fr']) ) {
      $header[$key] = str_replace('field_link', 'field_link_complaint', $columnName);
    } elseif ( $contentType == 'info_link' && in_array($columnName, ['field_link','field_link_fr']) ) {
      $header[$key] = str_replace('field_link', 'field_link_info', $columnName);
    }
  }

  return $header;
}

/**
 * To import data as Content type nodes.
 */
function create_node($filedata, $contentType) {
  drupal_flush_all_caches();
  global $base_url;

  $logFileName = "contentimportlog.txt";
  $logFile = fopen("sites/default/files/" . $logFileName, "w") or die("There is no permission to create log file. Please give permission for sites/default/file!");
  $fields = get_fields($contentType);
  $fieldNames = $fields['name'];
  $fieldTypes = $fields['type'];
  $fieldSettings = $fields['setting'];
  // Code for import csv file.
  $mimetype = 1;
  if ($mimetype) {
    $location = $filedata->destination;
    if (($handle = fopen($location, "r")) !== FALSE) {
      $keyIndex = [];
      $index = 0;
      $importHasErrors = false;
      $logVariationFields = "***************************** Content Import Begins ************************************\r\n";
      $headerFields = [];
      while (($data = fgetcsv($handle)) !== FALSE) {
        //echo '<pre>'; print_r ($data);die;
        $index++;
        $errors = [];
        if ($index < 2) {
          $data = format_header($data, $contentType);
          array_push($fieldNames, 'title');
          array_push($fieldTypes, 'text');
          array_push($fieldNames, 'langcode');
          array_push($fieldTypes, 'lang');
          array_push($fieldNames, 'author');
          array_push($fieldTypes, 'authored_by');
          if (array_search('langcode', $data) === FALSE) {
            $logVariationFields .= "Langcode missing --- Assuming EN as default langcode.. Import continues  \n \n";
            $data[count($data)] = 'langcode';
          }

          foreach ($fieldNames as $fieldValues) {
            $i = 0;
            foreach ($data as $dataValues) {
              if ($fieldValues == $dataValues) {
                //$logVariationFields .= "Data Type : " . $fieldValues . "  Matches \n";
                $keyIndex[$fieldValues] = $i;
              }
              $i++;
            }
          }

          // Header
          $headerFields = $data;
          continue;
        } else {
          $indexContentType = array_search('content_type', $headerFields);
          if ($data[$indexContentType] != $contentType) {
            continue;
          }
        }

        // Log record
        $logVariationFields .= sprintf("RECORD %s\r\n", $index-1);

        if ( !isset($keyIndex['title']) ||
            ($contentType == 'info_link' && !isset($keyIndex['field_link_info'])) ||
            ($contentType == 'complaint_link' && !isset($keyIndex['field_link_complaint'])) ) {
          \Drupal::messenger()
            ->addError(t('Title and/or link is missing in CSV file. Please add these fields and import again'));
          $url = $base_url . "/admin/config/content/contentimport";
          header('Location:' . $url);
          exit;
        }
        // Default Language.
        $nodeArrayEn = [];
        for ($f = 0; $f < count($fieldNames); $f++) {
          switch ($fieldTypes[$f]) {
            case 'image':
              //$logVariationFields .= "Importing Image (" . trim($data[$keyIndex[$fieldNames[$f]]]) . ") :: ";
              if (!empty($data[$keyIndex[$fieldNames[$f]]])) {
                $imgIndex = trim($data[$keyIndex[$fieldNames[$f]]]);
                $files = glob('sites/default/files/' . $contentType . '/images/' . $imgIndex);
                $fileExists = file_exists('sites/default/files/' . $imgIndex);
                if (!$fileExists) {
                  $images = [];
                  foreach ($files as $file_name) {
                    $image = File::create(['uri' => 'public://' . $contentType . '/images/' . basename($file_name)]);
                    $image->save();
                    $images[basename($file_name)] = $image;
                    $imageId = $images[basename($file_name)]->id();
                  }
                  $nodeArrayEn[$fieldNames[$f]] = [
                    [
                      'target_id' => $imageId,
                      'alt' => $images['title'],
                      'title' => $images['title'],
                    ],
                  ];
                  $logVariationFields .= "Image uploaded successfully \n ";
                }
              }
              $logVariationFields .= " Success \n";
              break;

            case 'entity_reference':
              //$logVariationFields .= "Importing Reference Type (" . $fieldSettings[$f]['target_type'] . ") :: ";
              $terms = [];
              if ($fieldSettings[$f]['target_type'] == 'taxonomy_term') {
                $target_bundles = $fieldSettings[$f]['handler_settings']['target_bundles'];
                // If vocabulary field settings target is single, assume it.
                if (count($target_bundles) == 1 && !empty($data[$keyIndex[$fieldNames[$f]]])) {
                  $terms = get_term_reference($target_bundles[key($target_bundles)], $data[$keyIndex[$fieldNames[$f]]]);
                }
                // If not, assume vocabulary is added with ":" delimiter.
                else {
                  $reference = explode(":", $data[$keyIndex[$fieldNames[$f]]]);
                  if (is_array($reference) && $reference[0] != '') {
                    $terms = get_term_reference($reference[0], $reference[1]);
                  }
                }
                //$logVariationFields .= sprintf('%s %s', $fieldNames[$f], print_r($terms, true));
                //echo '|'.$fieldNames[$f].':'.$data[$keyIndex[$fieldNames[$f]]].'|'.'<br>';
                if (!empty($terms)) {
                  $nodeArrayEn[$fieldNames[$f]] = $terms;
                }
              }
              elseif ($fieldSettings[$f]['target_type'] == 'user') {
                $userArray = explode(', ', $data[$keyIndex[$fieldNames[$f]]]);
                $users = get_user_info($userArray);
                $nodeArrayEn[$fieldNames[$f]] = $users;
              }
              elseif ($fieldSettings[$f]['target_type'] == 'node') {
                $nodeArrayEns = explode(':', $data[$keyIndex[$fieldNames[$f]]]);
                $nodeReference1 = get_node_id($nodeArrayEns);
                $nodeArrayEn[$fieldNames[$f]] = $nodeReference1;
              }
              //$logVariationFields .= " Success \n";
              break;

            case 'text_long':
            case 'text':
              //$logVariationFields .= "Importing Content (" . $fieldNames[$f] . ") :: ";
              $nodeArrayEn[$fieldNames[$f]] = [
                'value' => $data[$keyIndex[$fieldNames[$f]]],
                'format' => 'full_html',
              ];
              //$logVariationFields .= " Success \n";
              break;

            case 'entity_reference_revisions':
            case 'text_with_summary':
              //$logVariationFields .= "Importing Content (" . $fieldNames[$f] . ") :: ";
              $nodeArrayEn[$fieldNames[$f]] = [
                'summary' => substr(strip_tags($data[$keyIndex[$fieldNames[$f]]]), 0, 100),
                'value' => $data[$keyIndex[$fieldNames[$f]]],
                'format' => 'full_html',
              ];
              //$logVariationFields .= " Success \n";

              break;

            case 'datetime':
              //$logVariationFields .= "Importing Datetime (" . $fieldNames[$f] . ") :: ";
              $dateArray = explode(':', $data[$keyIndex[$fieldNames[$f]]]);
              if (count($dateArray) > 1) {
                $dateTimeStamp = strtotime($data[$keyIndex[$fieldNames[$f]]]);
                $newDateString = date('Y-m-d\TH:i:s', $dateTimeStamp);
              }
              else {
                $dateTimeStamp = strtotime($data[$keyIndex[$fieldNames[$f]]]);
                $newDateString = date('Y-m-d', $dateTimeStamp);
              }
              $nodeArrayEn[$fieldNames[$f]] = ["value" => $newDateString];
              //$logVariationFields .= " Success \n";
              break;

            case 'timestamp':
              //$logVariationFields .= "Importing Content (" . $fieldNames[$f] . ") :: ";
              $nodeArrayEn[$fieldNames[$f]] = ["value" => $data[$keyIndex[$fieldNames[$f]]]];
              //$logVariationFields .= " Success \n";
              break;

            case 'boolean':
              //$logVariationFields .= "Importing Boolean (" . $fieldNames[$f] . ") :: ";
              $affirmative = ['On','on','Yes','yes',1,'Oui','oui'];
              $nodeArrayEn[$fieldNames[$f]] = in_array($data[$keyIndex[$fieldNames[$f]]], $affirmative);/*  (
                $data[$keyIndex[$fieldNames[$f]]] == 'On' ||
                $data[$keyIndex[$fieldNames[$f]]] == 'Yes' ||
                $data[$keyIndex[$fieldNames[$f]]] == 'on' ||
                $data[$keyIndex[$fieldNames[$f]]] == 1 ||
                $data[$keyIndex[$fieldNames[$f]]] == 'yes') ? 1 : 0;*/
              //$logVariationFields .= " Success \n";
              break;

            case 'langcode':
              //$logVariationFields .= "Importing Langcode (" . $fieldNames[$f] . ") :: ";
              $nodeArrayEn[$fieldNames[$f]] = ($data[$keyIndex[$fieldNames[$f]]] != '') ? $data[$keyIndex[$fieldNames[$f]]] : 'en';
              //$logVariationFields .= " Success \n";
              break;

            case 'geolocation':
              //$logVariationFields .= "Importing Geolocation Field (" . $fieldNames[$f] . ") :: ";
              $geoArray = explode(";", $data[$keyIndex[$fieldNames[$f]]]);
              if (count($geoArray) > 0) {
                $geoMultiArray = [];
                for ($g = 0; $g < count($geoArray); $g++) {
                  $latlng = explode(",", $geoArray[$g]);
                  for ($l = 0; $l < count($latlng); $l++) {
                    $latlng[$l] = floatval(preg_replace("/\[^0-9,.]/", "", $latlng[$l]));
                  }
                  array_push(
                        $geoMultiArray, [
                          'lat' => $latlng[0],
                          'lng' => $latlng[1],
                        ]
                    );
                }
                $nodeArrayEn[$fieldNames[$f]] = $geoMultiArray;
              }
              else {
                $latlng = explode(",", $data[$keyIndex[$fieldNames[$f]]]);
                for ($l = 0; $l < count($latlng); $l++) {
                  $latlng[$l] = floatval(preg_replace("/\[^0-9,.]/", "", $latlng[$l]));
                }
                $nodeArrayEn[$fieldNames[$f]] = ['lat' => $latlng[0], 'lng' => $latlng[1]];
              }
              //$logVariationFields .= " Success \n";
              break;

            case 'entity_reference_revisions':
              /* In Progress */
              break;

            case 'list_string':
              //$logVariationFields .= "Importing Content (" . $fieldNames[$f] . ") :: ";
              $listArray = explode(",", $data[$keyIndex[$fieldNames[$f]]]);
              array_walk($listArray, 'trim');
              $nodeArrayEn[$fieldNames[$f]] = $listArray;
              //$logVariationFields .= " Success \n";
              break;

            case 'geofield':
              //$logVariationFields .= "Importing Geofield Field (" . $fieldNames[$f] . ") :: ";
              if (!empty(trim($data[$keyIndex[$fieldNames[$f]]]))) {
                $geoFieldArray = explode(";", trim($data[$keyIndex[$fieldNames[$f]]]));
                if (count($geoFieldArray) > 0) {
                  $geoFieldMultiArray = [];
                  for ($g = 0; $g < count($geoFieldArray); $g++) {
                    $latlng = explode(",", $geoFieldArray[$g]);
                    for ($l = 0; $l < count($latlng); $l++) {
                      $latlng[$l] = floatval($latlng[$l]);
                    }
                    array_push($geoFieldMultiArray,
                    \Drupal::service('geofield.wkt_generator')->WktBuildPoint([trim($latlng[1]), trim($latlng[0])]));
                  }
                  $nodeArrayEn[$fieldNames[$f]] = $geoFieldMultiArray;
                }
                else {
                  $latlng = explode(",", trim($data[$keyIndex[$fieldNames[$f]]]));
                  for ($l = 0; $l < count($latlng); $l++) {
                    $latlng[$l] = floatval($latlng[$l]);
                  }
                  $lonlat = \Drupal::service('geofield.wkt_generator')->WktBuildPoint([trim($latlng[1]), trim($latlng[0])]);
                  $nodeArrayEn[$fieldNames[$f]] = $lonlat;
                }
                //$logVariationFields .= " Success \n";
              }
              break;

            case 'authored_by':
              //$logVariationFields .= "Importing Content (" . $fieldNames[$f] . ") :: ";
              $user_id = get_user_id($data[$keyIndex[$fieldNames[$f]]]);
              $nodeArrayEn['uid'] = ($user_id > 0) ? $user_id : \Drupal::currentUser()->id();
              //$logVariationFields .= " Success \n";
              break;

            default:
              $nodeArrayEn[$fieldNames[$f]] = $data[$keyIndex[$fieldNames[$f]]];
              break;
          }
        }
        $nodeArrayEn['type'] = strtolower($contentType);
        $nodeArrayEn['promote'] = 0;
        $nodeArrayEn['sticky'] = 0;
        $nodeArrayEn['langcode'] = 'en';
        $nodeArrayEn['moderation_state'] = 'published';
        $errors = get_record_errors($nodeArrayEn);

        if (count($errors) > 0) {
          $importHasErrors = true;
          $logVariationFields .= sprintf("Errors: %s\r\n- Record not imported\r\n", implode(', ', $errors));
          $logVariationFields .= "----------------------------------------\r\n";
          continue;
        }

        // Build French translation data
        $nodeArrayFr = $nodeArrayEn;
        $nodeArrayFr['langcode'] = 'fr';
        foreach ($fieldNames as $fieldName) {
          $headerIndex = array_search($fieldName.'_fr', $headerFields);
          if ( $headerIndex !== false && $fieldName == 'title' ) {
            $nodeArrayFr[$fieldName]['value'] = $data[$headerIndex];
          } else if ( $headerIndex !== false ) {
            $nodeArrayFr[$fieldName] = $data[$headerIndex];
          }
        }

        $matchingEn = get_matching_nodes($nodeArrayEn);
        $matchingFr = get_matching_nodes($nodeArrayFr);
        //print "<pre>";
        //print_r($nodeArrayEn);
        //print_r($nodeArrayFr);
        //die();

        if (count($matchingEn) > 1) {
          // Log error
          $logVariationFields .= "- Multiple existing records found\r\n";
          continue;
        } elseif (count($matchingEn) == 1) {
          // We're doing an update
          $action = 'update';
          $node = Node::load($matchingEn[0]);
          foreach ($nodeArrayEn as $field => $values) {
            $node->set($field, $values);
          }
          $node->save();
          // Log
          $logVariationFields .= "- English Updated successfully\r\n";

          if ( $node->hasTranslation('fr') ) {
            $nodeFr = $node->getTranslation('fr');
            foreach ($nodeArrayFr as $field => $values) {
              $nodeFr->set($field, $values);
            }
            $nodeFr->save();

            // Log
            $logVariationFields .= "- French Updated successfully\r\n";
          } else if ($nodeArrayFr['title']['value'] != ''
              && (($contentType == 'complaint_link' && $nodeArrayFr['field_link_complaint'] != '') || ($contentType == 'info_link' && $nodeArrayFr['field_link_info'] != '')) ) {
            $nodeFr = $node->addTranslation('fr', $nodeArrayFr);
            $nodeFr->save();

            // Log
            $logVariationFields .= "- French Imported successfully\r\n";
          } else {
            // Log
            $logVariationFields .= "- French data not present\r\n";
          }

          //fwrite($logFile, $logVariationFields);
        } else {
          $action = 'insert';
          $nodeArrayEn['moderation_state'] = $nodeArrayFr['moderation_state'] = 'draft';
          if ($nodeArrayEn['title']['value'] != ''
              && (($contentType == 'complaint_link' && $nodeArrayEn['field_link_complaint'] != '') || ($contentType == 'info_link' && $nodeArrayEn['field_link_info'] != '')) ) {
            $node = Node::create($nodeArrayEn);

            // Log
            $logVariationFields .= "- English Imported successfully\r\n";

            // If French data exists, add the translation
            if ($nodeArrayFr['title']['value'] != ''
                && (($contentType == 'complaint_link' && $nodeArrayFr['field_link_complaint'] != '') || ($contentType == 'info_link' && $nodeArrayFr['field_link_info'] != '')) ) {
              $nodeFr = $node->addTranslation('fr', $nodeArrayFr);
              $nodeFr->save();

              // Log
              $logVariationFields .= "- French Imported successfully\r\n";
            } else {
              // Log
              $logVariationFields .= "- French data not present\r\n";
            }
            //fwrite($logFile, $logVariationFields);
          }
        }
        $logVariationFields .= "----------------------------------------\r\n";
      }
      fwrite($logFile, $logVariationFields);
      fclose($handle);

      //die('tta');
      if ($importHasErrors) {
        $message = t('Import completed with errors.  Please see error log.');
        \Drupal::messenger()->addWarning($message);
      } else {
        $message = t('Import completed successfully');
        \Drupal::messenger()->addMessage($message);
      }
      $url = $base_url . "/admin/config/content/contentimport";
      header('Location:' . $url);
      exit;
    }
  }
}
